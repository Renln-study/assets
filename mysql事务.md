### mysql 锁与事务

#### 1.为什么需要事务

- mysql是直接操作数据库记录，数据是唯一且一致的，必须保证一系列操作是一体的，比如转账场景下，转账业务里的所有数据库的操作是不可分割的，要么全部执行成功 ，要么全部失败，不允许出现中间状态的数据。

#### 事务是怎么实现的

- 事务具有四种特性，

  - A: 原子性：undolog日志
  - C：一致性：持久性+原子性+隔离性
  - I：隔离性：MVCC多版本控制
  - D：持久化：redolog日志

  ##### 为什么事务需要隔离性，事务并行会有什么影响

  > 并发执行的事务之间的不干扰主要是针对update/insert/del，但是在这些场景下，数据库处理模式（加锁）表现不同，因此也有隔离级别。

  ##### 事务并行的影响

  - 数据脏读：修改了事务未保存的数据

    > 假设当前数据库中同时有两个事务并发执行，分别为事务A和事务B，当事务A将数据1更新成2，然后事务B也需要将同一行的数据修改为3，假设事务A执行途中出现错误，无法继续执行，需要回滚数据，那么现在数据中的值将变为1，事务B对数据的修改就会消失，这种现象就是脏写问题。

  - 数据不可重复读：读取了还未提交的数据，然后事务回滚之后，再次读取数据，造成了不一致

    > 假设事务A和事务B并发执行，事务A首先查询某一行的数据，然后事务B对该行数据进行了修改，并将修改后的数据提交了，事务A在第二次查询的时候，就会出现两次查询结果不一样的情况，这种现象就是数据库事务的不可重复读。

  - 数据幻读：两次相同条件的查询期间，满足条件的数据出现了变动

    > 事务A需要使用到user表的数据总量，假设当前user表中共有3条数据，在事务A执行期间，事务B往user表中添加了一条数据，那么事务A下次查询user表中的数据总数时，则会显示为4条，这种现象就是数据库事务中最为神秘的幻读。

  #### 事务隔离级别

  > Mysql 对上述四种问题定义了四种隔离级别，从而避免在事务并发执行的时候产生的问题

  - read uncommitted 读未提交
  - read commited 读已提交
  - repeatable read 可重复读
  - serizlizable 串行化

#### 隔离性怎么保证的

#### 隔离级别是怎么实现的

#### 为什么要区分当前读和快照读

#### 隔离级别为什么这么设计

#### 不同的隔离级别会有什么问题吗

#### 锁可以避免这些问题吗

#### 间隙锁有什么优缺点

#### 怎么在RC隔离级别下避免幻读



